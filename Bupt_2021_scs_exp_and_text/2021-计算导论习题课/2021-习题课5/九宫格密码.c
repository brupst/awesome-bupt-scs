/*现在就请你写一段程序将这条路经转换成相应的密码。我们这里做一个限制，就是在画这条路经时，从一个点到另一个点，无论是横向还是纵向每次最多移动一个格。
也就是说如果我们按程序设计的习惯用（0，0）表示左上角的点，那么从它出发可能的移动只有三个，即可以移动到（0，1）、（1，0）和（1，1）三个点，
而不能像真实的九宫格密码那样可以移动到（1，2）（2，1）等点。
输入格式:
为两行，第一行为两个整数，代表起始点坐标，其中（0，0）代表左上角，（0，1）代表第一行中间，（0，2）代表右上角，（1，0）代表第二行最左等等，
其余以此规律类推。第二行为长度最长为8的字符串，代表每次移动的方向。字符串中仅可能含有 ‘1’、 ‘2’、 ‘3’、 ‘4’、 ‘6’、 ‘7’、 ‘8’、 ‘9’八种字符，
其中‘1’代表向左下移动、‘2’代表向下移动、‘3’代表向右下移动，‘4’代表向左移动，‘6’代表向右移动、‘7’代表向左上移动、‘8’代表向上移动、‘9’代表向右上移动。
输入保证合法，不存在移到九宫格以外的可能。
输出格式:
仅一行，为上述输入的路径所代表的密码。其中每个点所代表的数字同手机键盘，也就是说（0，0）点为1，（0，1）点为2，（0，2）点为3，（1，0）点为4等等。*/

#include<stdio.h>
int main()
{
    int lo[2];
    int nine[3][3];
    int x,y,i=0;
    char com[1000];

    for(x=0;x<3;x++)             //初始化
    {
        for(y=0;y<3;y++)
        {
            i++;
            nine[x][y]=i;
        }
    }

    scanf("%d%d",&lo[0],&lo[1]);
    getchar();
    gets(com);
    printf("%d",nine[lo[0]][lo[1]]);
    for(x=0;com[x]!='\0';x++)
    {
        if(com[x]=='1')
        {
            lo[0]++;
            lo[1]--;
        }
        else if (com[x]=='2')
            lo[0]++;
        else if (com[x]=='3'){
            lo[0]++;
            lo[1]++;
        }
        else if (com[x]=='4')
            lo[1]--;
        else if (com[x]=='6')
            lo[1]++;
        else if (com[x]=='7'){
            lo[0]--;
            lo[1]--;
        }
        else if (com[x]=='8')
            lo[0]--;
        else if (com[x]=='9'){
            lo[0]--;
            lo[1]++;
        }
        printf("%d",nine[lo[0]][lo[1]]);
    }
    return 0;
}