/*我们的屏幕大都是由一个一个像素点构成的。随着各个像素点亮度，色彩等不同，屏幕上就可以显示各种不同的图案。现在有一个屏幕有些奇怪，
当某一个像素点亮了以后，它周边的8个点（当这个点在屏幕的边上或角上时，这个数量是不一样的）都会亮。当然后亮的这8个点是因为这个中心点才亮的，
它们不再会导致它们各自周围的点再亮了（否则一个点亮了，整个屏幕就都亮了）。我们把前一种像素点叫主动亮的点。如图所示，如果那个红色的点为主动亮的点，
则红框内其他8个点则会因为这个主动亮的点也亮起来，但红框外边的点不会。
如果规定屏幕的左上角的坐标为（1，1），它的右边的点坐标依次为（1，2），（1，3）等等，它的下边的点坐标依次为（2，1），（3，1）等等。
其他点坐标也依此类推。
现在请你写一段程序来计算一下在某种情况下这个屏幕共亮了多少个像素点。
输入格式:
第一行为三个用空格分隔的整数m,n,c(0<m,n,c<10)，依次代表屏幕像素行数，列数以及主动亮的像素点的个数。后边共c行，每行均为两个用空格分隔的整数，
依次代表c个主动点亮的点的行坐标和列坐标。
测试用例保证输入合法且没有重复的主动亮的点。
输出格式:
所有亮了的像素点个数（包括主动亮的点）。*/

#include<stdio.h>
int main()
{
    int m,n,x,y;
    int a,b,c;
    int count=0;
    scanf("%d%d",&m,&n);
    int screen[m+2][n+2];
    for(x=0;x<m+2;x++)
    {
        for(y=0;y<n+2;y++)
            screen[x][y]=0;
    }
    scanf("%d",&a);
    for(x=0;x<a;x++)
    {
        scanf("%d%d",&b,&c);
        screen[b][c]=1;
        screen[b-1][c-1]=1;
        screen[b-1][c]=1;
        screen[b-1][c+1]=1;
        screen[b][c-1]=1;
        screen[b][c+1]=1;
        screen[b+1][c-1]=1;
        screen[b+1][c]=1;
        screen[b+1][c+1]=1;
    }
    for(x=1;x<m+1;x++)
    {
        for(y=1;y<n+1;y++)
        {
            if(screen[x][y]==1)
            {
                //printf("%d %d\n",x,y);
                count++;
            }
        }
    }
    printf("%d",count);
    return 0;
}